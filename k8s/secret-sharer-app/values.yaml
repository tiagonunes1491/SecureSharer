# values.yaml

# --- Backend Configuration ---
backend:
  replicaCount: 1
  image:
    # !! PHASE 6 TODO !!: Update with your actual ACR name if different
    repository: acrsecuresecsharer.azurecr.io/secure-secret-sharer-backend
    pullPolicy: IfNotPresent
    # !! PHASE 6 TODO !!: Use a specific, immutable tag for production readiness (e.g., git commit SHA)
    tag: "0.1.0"

  service:
    type: ClusterIP
    port: 8000 # Port the backend service will listen on

  # Service Account for the Backend (defined in templates/serviceaccount.yaml)
  # This SA is linked to the UAMI that has permissions for app-db-user, app-db-password, and app-master-encryption-key
  serviceAccount:
    create: true # Set to false if you are managing the SA outside this chart
    # This name 'secret-sharer-backend-sa' is used by templates/serviceaccount.yaml
    name: "secret-sharer-backend-sa"
    annotations: {} # Default annotations from template will use backend.keyVault.userAssignedIdentityClientID

  # Configuration for Azure Key Vault access by the Backend pod
  keyVault:
    # !! PHASE 4 TODO !!: Ensure this Key Vault name is correct for your environment.
    name: "kv-secure-secret-sharer"
    # !! PHASE 4 TODO !!: Ensure this Tenant ID is correct for your environment.
    tenantId: "6e05f665-11c4-4221-9eea-3065ede81619" # Your Azure Tenant ID
    # !! PHASE 4 TODO !!: Ensure this Client ID matches your 'id-secret-sharer-backend' UAMI after creation.
    userAssignedIdentityClientID: "fa376030-252d-443f-a32d-294e3cda90e1" # Client ID for Backend UAMI
    secrets:
      # These are the names of the secrets *in Azure Key Vault* that the backend needs.
      # !! PHASE 4 TODO !!: Ensure secrets with these exact names exist in AKV.
      dbUser: "app-db-user"                # AKV secret name for the application's DB username
      dbPassword: "app-db-password"        # AKV secret name for the application's DB password
      appMasterKey: "app-master-encryption-key" # AKV secret name for the application's master encryption key

# --- Database (PostgreSQL) Configuration ---
database:
  replicaCount: 1
  image:
    repository: postgres
    pullPolicy: IfNotPresent
    tag: "15.7-alpine3.20" # Using a specific immutable tag is good practice

  # Database name (used by init script and referred to by backend)
  auth:
    database: "secret_sharer_db"
    # Note: Initial admin user ('postgres') and its password, and the application user/password
    # are handled via SecretProviderClasses and the init script.

  persistence:
    enabled: true
    size: 1Gi
    # storageClass: "default" # Uncomment and set if you need a specific StorageClass

  # Service Account for the Database (defined in templates/database-serviceaccount.yaml)
  # This SA is linked to the UAMI that has permissions for 'postgres-password' (for init)
  # and 'app-db-password' (for the init script to create the app user).
  serviceAccount:
    create: true # Set to false if you are managing the SA outside this chart
    # name: "override-db-sa-name" # Optional: uncomment to override the default generated name from helpers
    annotations: {} # Default annotations from template will use database.serviceAccount.azureClientId
    # !! PHASE 4 TODO !!: Fill in the Client ID of the 'id-secret-sharer-db-init' UAMI after creation.
    azureClientId: "" # Placeholder for Database UAMI Client ID, e.g., "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"

  # Key Vault secrets needed ONLY for database initialization (by db-init-spc)
  keyVault: # This section is for the database's SecretProviderClass
    secrets:
      # This is the name of the secret *in Azure Key Vault* holding the desired password
      # for the initial 'postgres' user (used by db-init-spc).
      # !! PHASE 4 TODO !!: Ensure a secret with this exact name exists in AKV.
      initPassword: "postgres-password"

# --- Frontend Configuration ---
frontend:
  replicaCount: 1
  image:
    # !! PHASE 6 TODO !!: Update with your actual ACR name if different
    repository: acrsecuresecsharer.azurecr.io/secure-secret-sharer-frontend
    pullPolicy: IfNotPresent
    # !! PHASE 6 TODO !!: Use a specific, immutable tag
    tag: "0.1.0"

  service:
    type: ClusterIP # Will be ClusterIP, exposed via Ingress later
    port: 80 # Port Nginx listens on and service exposes

# --- Ingress Configuration (MVP Scope: basic definition, to be enabled in Phase 2/6) ---
ingress:
  enabled: true # Set to true in Phase 2 when ready to configure Ingress
  className: "azure/application-gateway" # For Kubernetes v1.18+ with IngressClass resource, if needed
  annotations: {}
    # kubernetes.io/ingress.class: nginx # Common annotation for Nginx Ingress Controller
  hosts:
    - host: "secretsharer.example.com" # !! PHASE 6 TODO !!: Replace with your actual desired hostname
      paths:
        - path: /
          pathType: Prefix # Or ImplementationSpecific / Exact
  tls: []
  # Example TLS configuration (requires a K8s secret with TLS cert and key):
  #  - secretName: secretsharer-tls
  #    hosts:
  #      - secretsharer.example.com

# --- Global settings / Overrides (from your original file) ---
# If you use these globally, ensure your templates support them or define them per-component.
# replicaCount: 1 # This was global in your file, now defined per-component which is more flexible.
# imagePullSecrets: []
# nameOverride: ""
# fullnameOverride: ""