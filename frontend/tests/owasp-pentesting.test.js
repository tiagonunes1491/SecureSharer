/* owasp-pentesting.test.js - OWASP Top 10 & Comprehensive Penetration Testing */

/**
 * COMPREHENSIVE SECURITY TESTING SUITE
 * 
 * This test suite covers:
 * - OWASP Top 10 (2021) compliance
 * - Advanced penetration testing scenarios
 * - Real-world attack vector simulation
 * - Defense-in-depth validation
 */

// Import security utilities
const fs = require('fs');
const path = require('path');

// Load utils.js content and eval it in the global context
const utilsPath = path.join(__dirname, '../static/utils.js');
const utilsContent = fs.readFileSync(utilsPath, 'utf8');
eval(utilsContent);

// Mock dependencies
const mockFetch = jest.fn();
global.fetch = mockFetch;

// Mock localStorage
const mockLocalStorage = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn()
};
global.localStorage = mockLocalStorage;

// Mock clipboard API
const mockClipboard = {
    writeText: jest.fn().mockResolvedValue()
};
global.navigator = {
    clipboard: mockClipboard,
    userAgent: 'Jest Test Environment'
};

describe('OWASP Top 10 (2021) Compliance & Penetration Testing', () => {
    
    beforeEach(() => {
        jest.clearAllMocks();
        document.body.innerHTML = '';
        mockLocalStorage.getItem.mockClear();
        mockLocalStorage.setItem.mockClear();
        mockFetch.mockClear();
    });

    describe('A01:2021 - Broken Access Control', () => {
        test('should prevent unauthorized access through URL manipulation', () => {
            // Test for broken access control via URL manipulation
            const maliciousUrls = [
                '../admin/secrets',
                '../../etc/passwd',
                '/api/admin/users',
                '%2e%2e%2fadmin',
                '..%c0%afadmin',
                'admin/../../../secrets'
            ];

            const sanitizeUrl = (url) => {
                // Basic sanitization that should be implemented
                return url.replace(/\.\./g, '').replace(/admin/gi, '').replace(/etc\/passwd/gi, '');
            };

            maliciousUrls.forEach(url => {
                const sanitized = sanitizeUrl(url);
                // After sanitization, these patterns should be removed
                expect(sanitized).not.toMatch(/\.\./);
                expect(sanitized).not.toMatch(/admin/i);
                expect(sanitized).not.toMatch(/etc\/passwd/);
            });
        });

        test('should prevent privilege escalation through parameter pollution', () => {
            const pollutedParams = {
                'userId': ['user123', 'admin'],
                'role': ['user', 'admin'],
                'permissions[]': ['read', 'write', 'admin']
            };

            // Should only accept single values, not arrays
            Object.entries(pollutedParams).forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    expect(value.length).toBeGreaterThan(1);
                    // Application should handle only first value or reject arrays
                }
            });
        });

        test('should prevent direct object reference attacks', () => {
            const sensitiveIds = [
                '1', '2', '999999',
                'admin-secret-123',
                '../other-user-secret',
                'guest',
                'root'
            ];

            const validateSecretId = (id) => {
                // Should be at least 8 characters and alphanumeric with dashes/underscores
                return /^[a-zA-Z0-9-_]{8,}$/.test(id);
            };

            sensitiveIds.forEach(id => {
                // Should validate that user can only access their own secrets
                const isValid = validateSecretId(id);
                if (id.length < 8 || /^[0-9]+$/.test(id) || ['guest', 'root'].includes(id)) {
                    expect(isValid).toBe(false);
                } else if (id === 'admin-secret-123') {
                    expect(isValid).toBe(true); // This one is actually valid format
                }
            });
        });
    });

    describe('A02:2021 - Cryptographic Failures', () => {
        test('should enforce HTTPS in production environments', () => {
            // Mock production environment
            const originalLocation = window.location;
            delete window.location;
            window.location = { protocol: 'https:', hostname: 'securesharer.com' };

            const isDevelopment = window.location.hostname === 'localhost' ||
                                window.location.hostname === '127.0.0.1' ||
                                window.location.protocol === 'file:';

            if (!isDevelopment) {
                expect(window.location.protocol).toBe('https:');
            }

            window.location = originalLocation;
        });

        test('should detect weak cryptographic implementations', () => {
            // Test for common weak crypto patterns
            const weakCryptoPatterns = [
                'Math.random()',
                'md5',
                'sha1',
                'des',
                'rc4',
                'base64' // if used for security
            ];

            const codeSnippets = [
                'const secret = Math.random().toString()',
                'const hash = md5(password)',
                'const token = btoa(userInfo)'
            ];

            codeSnippets.forEach(code => {
                const hasWeakCrypto = weakCryptoPatterns.some(pattern => 
                    code.toLowerCase().includes(pattern)
                );
                if (hasWeakCrypto) {
                    console.warn(`Potential weak crypto detected: ${code}`);
                }
            });
        });

        test('should prevent sensitive data exposure in URLs', () => {
            const sensitivePatterns = [
                /password/i,
                /secret/i,
                /token/i,
                /apikey/i,
                /session/i
            ];

            const testUrls = [
                'https://example.com/view.html#abc123',
                'https://example.com/login?user=test',
                'https://example.com/api/data'
            ];

            testUrls.forEach(url => {
                sensitivePatterns.forEach(pattern => {
                    if (pattern.test(url)) {
                        // Should not contain sensitive data in URL
                        expect(url).not.toMatch(pattern);
                    }
                });
            });
        });
    });

    describe('A03:2021 - Injection (Advanced)', () => {
        test('should prevent advanced XSS through template injection', () => {
            const templateInjectionPayloads = [
                '{{7*7}}',
                '${7*7}',
                '<%= 7*7 %>',
                '{{constructor.constructor("alert(1)")()}}',
                '${{7*7}}',
                '{{config.constructor.constructor("alert(1)")()}}',
                '#foreach($i in [1..$])$i#end',
                '${T(java.lang.Runtime).getRuntime().exec("calc")}'
            ];

            const sanitizeTemplateExpressions = (input) => {
                return input.replace(/\{\{.*?\}\}/g, '[REMOVED]')
                           .replace(/\$\{.*?\}/g, '[REMOVED]')
                           .replace(/<%.*?%>/g, '[REMOVED]')
                           .replace(/#foreach.*?#end/g, '[REMOVED]');
            };

            templateInjectionPayloads.forEach(payload => {
                const sanitized = sanitizeTemplateExpressions(payload);
                expect(sanitized).not.toContain('{{');
                expect(sanitized).not.toContain('${');
                expect(sanitized).not.toContain('<%');
                expect(sanitized).not.toContain('#foreach');
                if (payload.includes('constructor')) {
                    expect(sanitized).not.toContain('constructor');
                }
            });
        });

        test('should prevent CSS injection attacks', () => {
            const cssInjectionPayloads = [
                'body{background:url("javascript:alert(1)")}',
                '@import"javascript:alert(1)"',
                'expression(alert(1))',
                'url(data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==)',
                'url("data:text/html,<script>alert(1)</script>")',
                '-moz-binding:url("data:text/xml;charset=utf-8,%3Cscript%3Ealert(1)%3C/script%3E")'
            ];

            cssInjectionPayloads.forEach(payload => {
                const sanitized = payload.replace(/javascript:/gi, '')
                                        .replace(/expression\(/gi, '')
                                        .replace(/@import/gi, '')
                                        .replace(/data:text\/html/gi, '');
                expect(sanitized).not.toContain('javascript:');
                expect(sanitized).not.toContain('expression(');
            });
        });

        test('should prevent HTML5 injection vectors', () => {
            const html5Vectors = [
                '<svg onload=alert(1)>',
                '<iframe srcdoc="<script>alert(1)</script>">',
                '<object data="javascript:alert(1)">',
                '<embed src="javascript:alert(1)">',
                '<form><button formaction="javascript:alert(1)">',
                '<input onfocus=alert(1) autofocus>',
                '<audio controls><source src=x onerror=alert(1)>',
                '<video controls><source src=x onerror=alert(1)>'
            ];

            const advancedSanitizer = (input) => {
                const escaped = escapeHTML(input);
                // Remove event handlers and dangerous attributes
                return escaped.replace(/on\w+=/gi, 'data-removed=')
                             .replace(/javascript:/gi, 'blocked:')
                             .replace(/srcdoc=/gi, 'data-srcdoc=')
                             .replace(/formaction=/gi, 'data-formaction=');
            };

            html5Vectors.forEach(vector => {
                const sanitized = advancedSanitizer(vector);
                expect(sanitized).not.toContain('<svg');
                expect(sanitized).not.toContain('<iframe');
                expect(sanitized).not.toContain('<object');
                expect(sanitized).not.toContain('<embed');
                expect(sanitized).not.toContain('onload=');
                expect(sanitized).not.toContain('onerror=');
                expect(sanitized).not.toContain('onfocus=');
                expect(sanitized).not.toContain('javascript:');
            });
        });

        test('should prevent mutation XSS (mXSS)', () => {
            const mxssPayloads = [
                '<img src="x" id="dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0Iik7YS5zcmM9Imh0dHA6Ly94c3MuZXMvIjtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpOw==">',
                '<img src=x onerror="[&quot;1&quot;].join(&quot;eval(atob(this.id))&quot;)" id="YWxlcnQoMSk=">',
                '<div><img src=x onerror="location=atob(this.nextSibling.innerHTML)"><div>amF2YXNjcmlwdDphbGVydCgxKQ==</div></div>',
                '<img src=x onerror="[].constructor.constructor(atob(this.title))()" title="YWxlcnQoMSk=">'
            ];

            const mxssSanitizer = (input) => {
                const escaped = escapeHTML(input);
                // Remove dangerous functions and base64 content
                return escaped.replace(/atob\(/gi, 'blocked(')
                             .replace(/constructor/gi, 'blocked')
                             .replace(/location=/gi, 'blocked=')
                             .replace(/on\w+=/gi, 'data-removed=');
            };

            mxssPayloads.forEach(payload => {
                const sanitized = mxssSanitizer(payload);
                expect(sanitized).not.toContain('onerror=');
                expect(sanitized).not.toContain('atob(');
                expect(sanitized).not.toContain('constructor');
                expect(sanitized).not.toContain('location=');
            });
        });
    });

    describe('A04:2021 - Insecure Design', () => {
        test('should implement proper rate limiting logic', () => {
            const rateLimitTest = {
                requests: 0,
                lastRequestTime: 0,
                maxRequests: 10,
                timeWindow: 60000 // 1 minute
            };

            const simulateRequest = () => {
                const now = Date.now();
                if (now - rateLimitTest.lastRequestTime > rateLimitTest.timeWindow) {
                    rateLimitTest.requests = 0;
                    rateLimitTest.lastRequestTime = now;
                }
                rateLimitTest.requests++;
                return rateLimitTest.requests <= rateLimitTest.maxRequests;
            };

            // Simulate rapid requests
            for (let i = 0; i < 15; i++) {
                const allowed = simulateRequest();
                if (i < 10) {
                    expect(allowed).toBe(true);
                } else {
                    expect(allowed).toBe(false);
                }
            }
        });

        test('should prevent business logic bypasses', () => {
            const businessLogicChecks = {
                secretLength: (secret) => {
                    if (!secret) return false;
                    if (typeof secret !== 'string') return false;
                    return secret.length > 0 && secret.length <= 10000;
                },
                validOperation: (operation) => ['create', 'view'].includes(operation),
                secureTransport: (protocol) => protocol === 'https:' || protocol === 'file:', // file: for testing
                validSessionState: (state) => typeof state === 'object' && state !== null
            };

            const testInputs = [
                { secret: '', operation: 'delete', expectSecretValid: false, expectOperationValid: false },
                { secret: 'a'.repeat(100000), operation: 'create', expectSecretValid: false, expectOperationValid: true },
                { secret: 'test', operation: 'admin', expectSecretValid: true, expectOperationValid: false },
                { secret: null, operation: 'create', expectSecretValid: false, expectOperationValid: true },
                { secret: 'valid secret', operation: 'create', expectSecretValid: true, expectOperationValid: true }
            ];

            testInputs.forEach(input => {
                const secretValid = businessLogicChecks.secretLength(input.secret);
                const operationValid = businessLogicChecks.validOperation(input.operation);
                
                expect(secretValid).toBe(input.expectSecretValid);
                expect(operationValid).toBe(input.expectOperationValid);
            });
        });

        test('should implement secure state management', () => {
            const secureStateManager = {
                validateState: (state) => {
                    if (!state || typeof state !== 'object') return false;
                    if (state.__proto__ && Object.keys(state.__proto__).length > 0) return false;
                    if (state.constructor !== Object) return false;
                    return true;
                },
                sanitizeState: (state) => {
                    return JSON.parse(JSON.stringify(state));
                }
            };

            const maliciousStates = [
                { __proto__: { isAdmin: true } },
                { constructor: { prototype: { isAdmin: true } } },
                Object.create(null),
                new Map([['isAdmin', true]])
            ];

            maliciousStates.forEach(state => {
                const isValid = secureStateManager.validateState(state);
                expect(isValid).toBe(false);
            });
        });
    });

    describe('A05:2021 - Security Misconfiguration', () => {
        test('should detect insecure HTTP headers', () => {
            const securityHeaders = {
                'X-Frame-Options': 'DENY',
                'X-Content-Type-Options': 'nosniff',
                'X-XSS-Protection': '1; mode=block',
                'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
                'Content-Security-Policy': "default-src 'self'",
                'Referrer-Policy': 'strict-origin-when-cross-origin'
            };

            const insecureHeaders = {
                'X-Frame-Options': 'ALLOWALL',
                'X-XSS-Protection': '0',
                'Access-Control-Allow-Origin': '*',
                'X-Powered-By': 'Express 4.16.0'
            };

            const validateHeaders = (headers) => {
                const issues = [];
                if (headers['X-Frame-Options'] === 'ALLOWALL') issues.push('insecure-frame-options');
                if (headers['X-XSS-Protection'] === '0') issues.push('xss-protection-disabled');
                if (headers['Access-Control-Allow-Origin'] === '*') issues.push('cors-too-permissive');
                if (headers['X-Powered-By']) issues.push('information-disclosure');
                return issues;
            };

            const issues = validateHeaders(insecureHeaders);
            expect(issues.length).toBeGreaterThan(0);
            expect(issues).toContain('insecure-frame-options');
            expect(issues).toContain('xss-protection-disabled');
        });

        test('should prevent information disclosure through error messages', () => {
            const errorMessages = [
                'Database connection failed: mysql://user:pass@localhost:3306/db',
                'File not found: /etc/passwd',
                'Stack trace: at Function.Module._load (/app/secret.js:123:45)',
                'SQL Error: Table \'users\' doesn\'t exist',
                'Authentication failed for user admin with password 123456'
            ];

            const sanitizedMessages = errorMessages.map(msg => {
                return msg.replace(/mysql:\/\/.*?@/, 'mysql://***@')
                         .replace(/\/etc\/\w+/, '/***')
                         .replace(/\/app\/\w+\.js:\d+:\d+/, '/app/***.js')
                         .replace(/Table '[^']+' doesn't exist/, 'Database error')
                         .replace(/password \w+/, 'password ***');
            });

            sanitizedMessages.forEach((sanitized, index) => {
                expect(sanitized).not.toContain('mysql://user:pass@');
                expect(sanitized).not.toContain('/etc/passwd');
                expect(sanitized).not.toContain('secret.js');
                expect(sanitized).not.toContain('password 123456');
            });
        });

        test('should validate Content Security Policy implementation', () => {
            const cspPolicies = [
                "default-src 'self'",
                "script-src 'self' 'unsafe-inline'", // Insecure
                "object-src 'none'",
                "style-src 'self' 'unsafe-eval'", // Insecure
                "img-src 'self' data: https:"
            ];

            const insecurePolicies = cspPolicies.filter(policy => 
                policy.includes("'unsafe-inline'") || 
                policy.includes("'unsafe-eval'") ||
                policy.includes("*")
            );

            expect(insecurePolicies.length).toBeGreaterThan(0); // Should detect insecure policies
            insecurePolicies.forEach(policy => {
                expect(policy).toMatch(/'unsafe-(inline|eval)'|\*/);
            });
        });
    });

    describe('A06:2021 - Vulnerable and Outdated Components', () => {
        test('should detect vulnerable dependency patterns', () => {
            const vulnerableDependencies = [
                { name: 'lodash', version: '4.17.19', vulnerability: 'Prototype pollution' },
                { name: 'jquery', version: '1.12.4', vulnerability: 'XSS vulnerability' },
                { name: 'marked', version: '0.3.6', vulnerability: 'XSS vulnerability' },
                { name: 'handlebars', version: '4.0.5', vulnerability: 'Template injection' }
            ];

            const checkVulnerability = (dep) => {
                const vulnerableVersions = {
                    'lodash': ['4.17.19', '4.17.20'],
                    'jquery': ['1.12.4', '2.2.4', '3.4.1'],
                    'marked': ['0.3.6', '0.3.7'],
                    'handlebars': ['4.0.5', '4.1.2']
                };

                return vulnerableVersions[dep.name] && 
                       vulnerableVersions[dep.name].includes(dep.version);
            };

            vulnerableDependencies.forEach(dep => {
                const isVulnerable = checkVulnerability(dep);
                if (isVulnerable) {
                    console.warn(`Vulnerable dependency detected: ${dep.name}@${dep.version}`);
                }
                expect(isVulnerable).toBe(true); // For testing - these are known vulnerable versions
            });
        });

        test('should validate dependency integrity', () => {
            const dependencyChecksums = {
                'react@17.0.2': 'sha384-99d7bbdcfef3c9f8dd6b8b09faf6e5b9d1b3b4567890123456',
                'lodash@4.17.21': 'sha384-91d8bbdc9e9f8dd6b8b09faf6e5b9d1b3b9f7890123456789',
                'axios@0.21.1': 'sha384-99d7bbdcfef3c9f8dd6b8b09faf6e5b9d1b3b0123456789012'
            };

            const validateSRI = (checksum) => {
                return /^sha(256|384|512)-[a-zA-Z0-9+\/=]+$/.test(checksum) && checksum.length > 50;
            };

            Object.entries(dependencyChecksums).forEach(([pkg, checksum]) => {
                expect(validateSRI(checksum)).toBe(true);
                expect(checksum).toMatch(/^sha(256|384|512)-/);
                expect(checksum.length).toBeGreaterThan(50);
            });
        });
    });

    describe('A07:2021 - Identification and Authentication Failures', () => {
        test('should prevent session fixation attacks', () => {
            const sessionManager = {
                generateSessionId: () => {
                    const crypto = require('crypto');
                    return crypto.randomBytes(32).toString('hex');
                },
                validateSessionId: (sessionId) => {
                    return /^[a-f0-9]{64}$/.test(sessionId);
                },
                regenerateSession: (oldSessionId) => {
                    // Should invalidate old session and create new one
                    return sessionManager.generateSessionId();
                }
            };

            const maliciousSessionIds = [
                'admin',
                'guest',
                '12345',
                'AAAAAAAAAAAAAAAAAAAA',
                '../../../etc/passwd',
                '<script>alert(1)</script>'
            ];

            maliciousSessionIds.forEach(sessionId => {
                const isValid = sessionManager.validateSessionId(sessionId);
                expect(isValid).toBe(false);
            });

            const validSessionId = sessionManager.generateSessionId();
            expect(sessionManager.validateSessionId(validSessionId)).toBe(true);
        });

        test('should implement secure authentication logic', () => {
            const authValidator = {
                validateCredentials: (username, password) => {
                    if (!username || !password) return false;
                    if (username.length < 3 || username.length > 50) return false;
                    if (password.length < 8) return false;
                    if (!/[A-Z]/.test(password)) return false;
                    if (!/[a-z]/.test(password)) return false;
                    if (!/[0-9]/.test(password)) return false;
                    return true;
                },
                preventTimingAttacks: (inputHash, storedHash) => {
                    // Constant-time comparison simulation
                    if (inputHash.length !== storedHash.length) return false;
                    let result = 0;
                    for (let i = 0; i < inputHash.length; i++) {
                        result |= inputHash.charCodeAt(i) ^ storedHash.charCodeAt(i);
                    }
                    return result === 0;
                }
            };

            const weakCredentials = [
                { username: '', password: 'password123' },
                { username: 'admin', password: '123' },
                { username: 'user', password: 'password' },
                { username: 'a', password: 'Password123' }
            ];

            weakCredentials.forEach(creds => {
                const isValid = authValidator.validateCredentials(creds.username, creds.password);
                expect(isValid).toBe(false);
            });
        });
    });

    describe('A08:2021 - Software and Data Integrity Failures', () => {
        test('should validate data integrity', () => {
            const integrityChecker = {
                validateJSON: (jsonString) => {
                    try {
                        const parsed = JSON.parse(jsonString);
                        if (parsed.__proto__ || parsed.constructor !== Object) {
                            return false;
                        }
                        return true;
                    } catch {
                        return false;
                    }
                },
                validateDataStructure: (data, schema) => {
                    for (const [key, expectedType] of Object.entries(schema)) {
                        if (!(key in data) || typeof data[key] !== expectedType) {
                            return false;
                        }
                    }
                    return true;
                }
            };

            const maliciousJSONInputs = [
                '{"__proto__": {"isAdmin": true}}',
                '{"constructor": {"prototype": {"isAdmin": true}}}',
                '{"length": 0, "0": "malicious"}',
                '{"toString": "function(){return \'hacked\';}"}',
                'null',
                'undefined',
                '[]'
            ];

            maliciousJSONInputs.forEach(input => {
                const isValid = integrityChecker.validateJSON(input);
                if (input.includes('__proto__') || input.includes('constructor')) {
                    expect(isValid).toBe(false);
                }
            });

            const validData = { secret: 'test', timestamp: '2023-01-01' };
            const schema = { secret: 'string', timestamp: 'string' };
            expect(integrityChecker.validateDataStructure(validData, schema)).toBe(true);
        });

        test('should prevent supply chain attacks through CDN validation', () => {
            const cdnValidator = {
                validateSRI: (url, expectedHash) => {
                    const sriPattern = /^sha(256|384|512)-[a-zA-Z0-9+\/=]+$/;
                    return sriPattern.test(expectedHash);
                },
                validateCDNSource: (url) => {
                    const trustedCDNs = [
                        'cdnjs.cloudflare.com',
                        'cdn.jsdelivr.net',
                        'unpkg.com',
                        'ajax.googleapis.com'
                    ];
                    try {
                        const urlObj = new URL(url);
                        return trustedCDNs.includes(urlObj.hostname);
                    } catch {
                        return false;
                    }
                }
            };

            const maliciousCDNs = [
                'http://evil-cdn.com/script.js',
                'https://fake-cdnjs.com/jquery.js',
                'https://malicious-site.com/bootstrap.css',
                'javascript:alert(1)'
            ];

            maliciousCDNs.forEach(url => {
                const isTrusted = cdnValidator.validateCDNSource(url);
                expect(isTrusted).toBe(false);
            });

            const validSRIHashes = [
                'sha256-abc123def456ghi789jkl012mno345pqr678stu901vwx234yz=',
                'sha384-abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOP=',
                'sha512-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ='
            ];

            validSRIHashes.forEach(hash => {
                expect(cdnValidator.validateSRI('test-url', hash)).toBe(true);
            });
        });
    });

    describe('A09:2021 - Security Logging and Monitoring Failures', () => {
        test('should implement comprehensive security logging', () => {
            const securityLogger = {
                logSecurityEvent: function(event, details) {
                    const logEntry = {
                        timestamp: new Date().toISOString(),
                        event: event,
                        details: details,
                        severity: this.getSeverity(event),
                        source: 'frontend'
                    };
                    return logEntry;
                },
                getSeverity: function(event) {
                    const severityMap = {
                        'xss-attempt': 'HIGH',
                        'injection-attempt': 'HIGH',
                        'unauthorized-access': 'CRITICAL',
                        'rate-limit-exceeded': 'MEDIUM',
                        'invalid-input': 'LOW'
                    };
                    return severityMap[event] || 'LOW';
                }
            };

            const securityEvents = [
                { event: 'xss-attempt', details: { payload: '<script>alert(1)</script>' } },
                { event: 'injection-attempt', details: { payload: '{{7*7}}' } },
                { event: 'unauthorized-access', details: { url: '/admin/secrets' } },
                { event: 'rate-limit-exceeded', details: { requests: 100 } }
            ];

            securityEvents.forEach(({ event, details }) => {
                const logEntry = securityLogger.logSecurityEvent(event, details);
                expect(logEntry.timestamp).toBeDefined();
                expect(logEntry.event).toBe(event);
                expect(logEntry.severity).toBeDefined();
                expect(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']).toContain(logEntry.severity);
            });
        });

        test('should detect and log anomalous behavior', () => {
            const anomalyDetector = {
                detectAnomalies: (requests) => {
                    const anomalies = [];
                    
                    // Detect rapid successive requests
                    const timeWindow = 5000; // 5 seconds
                    const maxRequests = 10;
                    let recentRequests = 0;
                    
                    requests.forEach(request => {
                        if (Date.now() - request.timestamp < timeWindow) {
                            recentRequests++;
                        }
                    });
                    
                    if (recentRequests > maxRequests) {
                        anomalies.push('rate-limit-exceeded');
                    }
                    
                    // Detect suspicious payloads
                    requests.forEach(request => {
                        if (request.payload) {
                            if (/<script|javascript:|data:text\/html/i.test(request.payload)) {
                                anomalies.push('suspicious-payload');
                            }
                        }
                    });
                    
                    return anomalies;
                }
            };

            const suspiciousRequests = [
                { timestamp: Date.now(), payload: '<script>alert(1)</script>' },
                { timestamp: Date.now(), payload: 'javascript:alert(1)' },
                { timestamp: Date.now(), payload: 'normal text' },
                { timestamp: Date.now() - 1000, payload: '<img src=x onerror=alert(1)>' }
            ];

            const anomalies = anomalyDetector.detectAnomalies(suspiciousRequests);
            expect(anomalies).toContain('suspicious-payload');
            expect(anomalies.length).toBeGreaterThan(0);
        });
    });

    describe('A10:2021 - Server-Side Request Forgery (SSRF)', () => {
        test('should prevent SSRF through URL validation', () => {
            const ssrfValidator = {
                validateURL: (url) => {
                    try {
                        const urlObj = new URL(url);
                        
                        // Block private IP ranges
                        const blockedHosts = [
                            '127.0.0.1', 'localhost',
                            '10.', '172.16.', '172.17.', '172.18.', '172.19.',
                            '172.20.', '172.21.', '172.22.', '172.23.',
                            '172.24.', '172.25.', '172.26.', '172.27.',
                            '172.28.', '172.29.', '172.30.', '172.31.',
                            '192.168.', '169.254.'
                        ];
                        
                        // Block dangerous protocols
                        const blockedProtocols = ['file:', 'gopher:', 'ftp:', 'dict:', 'ldap:'];
                        
                        if (blockedProtocols.includes(urlObj.protocol)) {
                            return false;
                        }
                        
                        if (blockedHosts.some(host => urlObj.hostname.startsWith(host))) {
                            return false;
                        }
                        
                        return true;
                    } catch {
                        return false;
                    }
                }
            };

            const ssrfPayloads = [
                'http://127.0.0.1:80/',
                'http://localhost:22/',
                'http://192.168.1.1/admin',
                'http://10.0.0.1/internal',
                'file:///etc/passwd',
                'gopher://127.0.0.1:25/',
                'dict://127.0.0.1:11211/',
                'ftp://127.0.0.1:21/'
            ];

            ssrfPayloads.forEach(url => {
                const isValid = ssrfValidator.validateURL(url);
                expect(isValid).toBe(false);
            });

            const validUrls = [
                'https://api.example.com/data',
                'https://cdn.example.com/image.jpg'
            ];

            validUrls.forEach(url => {
                const isValid = ssrfValidator.validateURL(url);
                expect(isValid).toBe(true);
            });
        });
    });

    describe('Advanced Penetration Testing Scenarios', () => {
        test('should prevent clickjacking attacks', () => {
            const clickjackingProtection = {
                validateFrameOptions: (headers) => {
                    return headers['X-Frame-Options'] === 'DENY' || 
                           headers['X-Frame-Options'] === 'SAMEORIGIN';
                },
                validateCSP: (csp) => {
                    return csp.includes("frame-ancestors 'none'") ||
                           csp.includes("frame-ancestors 'self'");
                }
            };

            const secureHeaders = {
                'X-Frame-Options': 'DENY',
                'Content-Security-Policy': "frame-ancestors 'none'"
            };

            const insecureHeaders = {
                'X-Frame-Options': 'ALLOWALL'
            };

            expect(clickjackingProtection.validateFrameOptions(secureHeaders)).toBe(true);
            expect(clickjackingProtection.validateFrameOptions(insecureHeaders)).toBe(false);
            expect(clickjackingProtection.validateCSP(secureHeaders['Content-Security-Policy'])).toBe(true);
        });

        test('should prevent DOM clobbering attacks', () => {
            const domClobberingProtection = {
                validateElementId: (id) => {
                    const dangerousIds = [
                        'constructor', 'prototype', '__proto__',
                        'toString', 'valueOf', 'hasOwnProperty',
                        'isPrototypeOf', 'propertyIsEnumerable'
                    ];
                    return !dangerousIds.includes(id);
                },
                sanitizeAttributes: (attributes) => {
                    const sanitized = {};
                    Object.entries(attributes).forEach(([key, value]) => {
                        if (!key.startsWith('__') && !key.includes('prototype')) {
                            sanitized[key] = value;
                        }
                    });
                    return sanitized;
                }
            };

            const maliciousIds = [
                'constructor',
                'prototype', 
                '__proto__',
                'toString',
                'valueOf'
            ];

            maliciousIds.forEach(id => {
                expect(domClobberingProtection.validateElementId(id)).toBe(false);
            });

            const maliciousAttributes = {
                'id': 'test',
                '__proto__': 'malicious',
                'prototype': 'evil',
                'data-valid': 'ok'
            };

            const sanitized = domClobberingProtection.sanitizeAttributes(maliciousAttributes);
            expect(Object.prototype.hasOwnProperty.call(sanitized, '__proto__')).toBe(false);
            expect(Object.prototype.hasOwnProperty.call(sanitized, 'prototype')).toBe(false);
            expect(sanitized.id).toBe('test');
            expect(sanitized['data-valid']).toBe('ok');
        });

        test('should prevent cache poisoning attacks', () => {
            const cachePoisoningProtection = {
                validateCacheHeaders: (headers) => {
                    const suspiciousHeaders = [
                        'X-Forwarded-Host',
                        'X-Forwarded-Server', 
                        'X-Forwarded-Scheme',
                        'X-Host',
                        'X-Original-URL'
                    ];
                    
                    return !suspiciousHeaders.some(header => 
                        headers[header] && (
                            headers[header].includes('evil.com') || 
                            headers[header].includes('malicious.com')
                        )
                    );
                },
                sanitizeHostHeader: (host) => {
                    const allowedHosts = ['securesharer.com', 'localhost'];
                    return allowedHosts.includes(host);
                }
            };

            const maliciousHeaders = {
                'Host': 'evil.com',
                'X-Forwarded-Host': 'malicious.com',
                'X-Original-URL': '/admin/secrets'
            };

            const legitimateHeaders = {
                'Host': 'securesharer.com',
                'User-Agent': 'Mozilla/5.0...'
            };

            expect(cachePoisoningProtection.validateCacheHeaders(maliciousHeaders)).toBe(false);
            expect(cachePoisoningProtection.validateCacheHeaders(legitimateHeaders)).toBe(true);
            expect(cachePoisoningProtection.sanitizeHostHeader('evil.com')).toBe(false);
            expect(cachePoisoningProtection.sanitizeHostHeader('securesharer.com')).toBe(true);
        });

        test('should prevent race condition attacks', () => {
            const raceConditionProtection = {
                requestQueue: new Map(),
                processRequest: function(userId, operation) {
                    const key = `${userId}-${operation}`;
                    const now = Date.now();
                    
                    if (this.requestQueue.has(key)) {
                        const lastRequest = this.requestQueue.get(key);
                        if (now - lastRequest < 1000) { // 1 second cooldown
                            return false; // Reject duplicate request
                        }
                    }
                    
                    this.requestQueue.set(key, now);
                    return true;
                },
                cleanup: function() {
                    const now = Date.now();
                    this.requestQueue.forEach((timestamp, key) => {
                        if (now - timestamp > 60000) { // Clean up old entries
                            this.requestQueue.delete(key);
                        }
                    });
                }
            };

            // Simulate race condition attempt
            const userId = 'user123';
            const operation = 'create-secret';
            
            expect(raceConditionProtection.processRequest(userId, operation)).toBe(true);
            expect(raceConditionProtection.processRequest(userId, operation)).toBe(false); // Should be rejected
            
            // Wait and cleanup
            setTimeout(() => {
                raceConditionProtection.cleanup();
                expect(raceConditionProtection.processRequest(userId, operation)).toBe(true);
            }, 1100);
        });

        test('should prevent timing attacks', () => {
            const timingAttackProtection = {
                constantTimeEqual: (a, b) => {
                    if (a.length !== b.length) {
                        return false;
                    }
                    
                    let result = 0;
                    for (let i = 0; i < a.length; i++) {
                        result |= a.charCodeAt(i) ^ b.charCodeAt(i);
                    }
                    
                    return result === 0;
                },
                addRandomDelay: async () => {
                    const delay = Math.random() * 100 + 50; // 50-150ms random delay
                    return new Promise(resolve => setTimeout(resolve, delay));
                },
                measureTiming: (fn) => {
                    const start = performance.now();
                    fn();
                    const end = performance.now();
                    return end - start;
                }
            };

            const secret1 = 'correct-secret-123';
            const secret2 = 'wrong-secret-456';
            const guess1 = 'correct-secret-123';
            const guess2 = 'wrong-secret-456';

            // Test constant time comparison
            expect(timingAttackProtection.constantTimeEqual(secret1, guess1)).toBe(true);
            expect(timingAttackProtection.constantTimeEqual(secret1, guess2)).toBe(false);

            // Measure timing to ensure constant time
            const time1 = timingAttackProtection.measureTiming(() => {
                timingAttackProtection.constantTimeEqual(secret1, guess1);
            });
            
            const time2 = timingAttackProtection.measureTiming(() => {
                timingAttackProtection.constantTimeEqual(secret1, guess2);
            });

            // Times should be similar (within reasonable variance)
            const timeDifference = Math.abs(time1 - time2);
            expect(timeDifference).toBeLessThan(5); // Less than 5ms difference
        });
    });
});